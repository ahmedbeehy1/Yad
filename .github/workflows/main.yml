name: Windows RDP Full Persistent System

on:
  workflow_dispatch:
    inputs:
      action:
        description: 'Ú©Ø±Ø¯Ø§Ø±'
        required: true
        default: 'start'
        type: choice
        options:
        - start
        - restore
        - backup

env:
  VHD_PATH: "D:\\SystemBackup.vhdx"
  VHD_SIZE: "50GB"
  MOUNT_PATH: "C:\\"
  RDP_USER: "Yad"
  RDP_PASS: "Ahmed1122$"

jobs:
  persistent-system:
    runs-on: windows-latest
    
    steps:
      - name: Ú†ÛÚ©Ø±Ø¯Ù†ÛŒ Ø¯Ø±Ø§ÛŒÚ¤ÛŒ Ù‡Û•Ù…ÛŒØ´Û•ÛŒÛŒ
        run: |
          # Ù¾Ø´Ú©Ù†ÛŒÙ†ÛŒ Ø¦Û•Ú¯Û•Ø± Ø¯Ø±Ø§ÛŒÚ¤ÛŒ VHD Ø¨ÙˆÙˆÙ†ÛŒ Ù‡Û•Ø¨ÛØª
          $vhdExists = Test-Path "${{ env.VHD_PATH }}"
          
          if (-not $vhdExists -or "${{ github.event.inputs.action }}" -eq 'start') {
              Write-Host "ğŸš€ Ø¯Ø±ÙˆØ³ØªÚ©Ø±Ø¯Ù†ÛŒ Ø³ÛŒØ³ØªÙ…ÛÚ©ÛŒ Ù†ÙˆÛ..."
              
              # Ù¡. Ø¯Ø±ÙˆØ³ØªÚ©Ø±Ø¯Ù†ÛŒ VHD Ø¨Û• diskpart
              Write-Host "ğŸ’¾ Ø¯Ø±ÙˆØ³ØªÚ©Ø±Ø¯Ù†ÛŒ VHD..."
              
              # Ø¯Ø±ÙˆØ³ØªÚ©Ø±Ø¯Ù†ÛŒ ÙØ§ÛŒÙ„ÛŒ diskpart
              $diskpartContent = "create vdisk file=`"${{ env.VHD_PATH }}`" maximum=${{ env.VHD_SIZE }} type=expandable`n"
              $diskpartContent += "select vdisk file=`"${{ env.VHD_PATH }}`"`n"
              $diskpartContent += "attach vdisk`n"
              $diskpartContent += "create partition primary`n"
              $diskpartContent += "format fs=ntfs quick label=`"PersistentSystem`"`n"
              $diskpartContent += "assign letter=S`n"
              $diskpartContent += "detach vdisk`n"
              
              $diskpartContent | Out-File -FilePath "$env:TEMP\create_vhd.txt" -Encoding ASCII
              diskpart /s "$env:TEMP\create_vhd.txt"
              
              # Ù¢. Ù„Ú©Ø§Ù†Ø¯Ù†ÛŒ VHD
              $mountContent = "select vdisk file=`"${{ env.VHD_PATH }}`"`n"
              $mountContent += "attach vdisk`n"
              
              $mountContent | Out-File -FilePath "$env:TEMP\mount_vhd.txt" -Encoding ASCII
              diskpart /s "$env:TEMP\mount_vhd.txt"
              
              # Ú†Ø§ÙˆÛ•Ú•ÙˆØ§Ù†ÛŒ Ø¨Û† Ù„Ú©Ø§Ù†Ø¯Ù†
              Start-Sleep -Seconds 5
              
              # Ù£. Ú©Û†Ù¾ÛŒÚ©Ø±Ø¯Ù†ÛŒ Ù‡Û•Ù…ÙˆÙˆ Ø³ÛŒØ³ØªÛ•Ù…Û•Ú©Û• Ø¨Û† VHD
              Write-Host "ğŸ“¦ Ú©Û†Ù¾ÛŒÚ©Ø±Ø¯Ù†ÛŒ Ù‡Û•Ù…ÙˆÙˆ Ø³ÛŒØ³ØªÛ•Ù…Û•Ú©Û•..."
              robocopy C:\ S:\ /MIR /COPYALL /R:0 /W:0 /NP /NFL /NDL /XF pagefile.sys hiberfil.sys swapfile.sys /XD "Windows.old" "WinSxS" "\System Volume Information" "\Recovery"
              
              # Ù¤. Ø¯Ø²Ø§Ù†ÛŒ Ù„Û• Ø¯Ø±Ø§ÛŒÚ¤
              $detachContent = "select vdisk file=`"${{ env.VHD_PATH }}`"`n"
              $detachContent += "detach vdisk`n"
              
              $detachContent | Out-File -FilePath "$env:TEMP\detach_vhd.txt" -Encoding ASCII
              diskpart /s "$env:TEMP\detach_vhd.txt"
              
          } elseif ("${{ github.event.inputs.action }}" -eq 'restore') {
              Write-Host "ğŸ”„ Ú¯Û•Ú•Ø§Ù†Ø¯Ù†Û•ÙˆÛ•ÛŒ Ø³ÛŒØ³ØªÙ… Ù„Û• VHD..."
              
              # Ù¡. Ù„Ú©Ø§Ù†Ø¯Ù†ÛŒ VHD
              $mountContent = "select vdisk file=`"${{ env.VHD_PATH }}`"`n"
              $mountContent += "attach vdisk`n"
              
              $mountContent | Out-File -FilePath "$env:TEMP\mount_restore.txt" -Encoding ASCII
              diskpart /s "$env:TEMP\mount_restore.txt"
              
              # Ú†Ø§ÙˆÛ•Ú•ÙˆØ§Ù†ÛŒ Ø¨Û† Ù„Ú©Ø§Ù†Ø¯Ù†
              Start-Sleep -Seconds 5
              
              # Ù¢. ÙØ±Ù…Ø§Øª Ú©Ø±Ø¯Ù†ÛŒ Ø¯Ø±Ø§ÛŒÚ¤ÛŒ Ø¦Û•Ø³ÚµÛŒ (C:) Ùˆ Ú¯ÙˆØ§Ø³ØªÙ†Û•ÙˆÛ•ÛŒ Ø¯Ø§ØªØ§
              Write-Host "ğŸ”„ Ú¯ÙˆØ§Ø³ØªÙ†Û•ÙˆÛ•ÛŒ Ù‡Û•Ù…ÙˆÙˆ Ø¯Ø§ØªØ§Ú©Ø§Ù†..."
              
              # ÛŒÛ•Ú©Û•Ù…: Ø¯Ø±ÙˆØ³ØªÚ©Ø±Ø¯Ù†ÛŒ Backup
              New-Item -ItemType Directory -Path "S:\Backup" -Force
              
              # Ú©Û†Ù¾ÛŒÚ©Ø±Ø¯Ù†ÛŒ Ù‡Û•Ù…ÙˆÙˆ Ø¯Ø±Ø§ÛŒÚ¤Û•Ú©Ø§Ù† Ø¨Û† Backup
              Get-WmiObject Win32_LogicalDisk | Where-Object {$_.DriveType -eq 3} | ForEach-Object {
                  $driveLetter = $_.DeviceID.TrimEnd(':')
                  $sourceDrive = "$driveLetter`:\"
                  $backupPath = "S:\Backup\${driveLetter}_Drive"
                  
                  if (Test-Path $sourceDrive -and $driveLetter -ne "S") {
                      Write-Host "Ú©Û†Ù¾ÛŒÚ©Ø±Ø¯Ù†ÛŒ $sourceDrive..."
                      New-Item -ItemType Directory -Path $backupPath -Force
                      robocopy $sourceDrive $backupPath /E /COPYALL /R:0 /W:0 /NP /NFL /NDL /XF pagefile.sys hiberfil.sys swapfile.sys
                  }
              }
              
              # Ø¯ÙˆÙˆÛ•Ù…: Ú¯ÙˆØ§Ø³ØªÙ†Û•ÙˆÛ• Ù„Û• VHD Ø¨Û† C:
              Write-Host "Ú¯ÙˆØ§Ø³ØªÙ†Û•ÙˆÛ•ÛŒ Ø¯Ø§ØªØ§ Ù„Û• VHD Ø¨Û† C:..."
              robocopy S:\ C:\ /E /COPYALL /R:0 /W:0 /NP /NFL /NDL /XF "pagefile.sys" "hiberfil.sys" "swapfile.sys"
              
              # Ù£. Ø¯Ø²Ø§Ù†ÛŒ Ù„Û• Ø¯Ø±Ø§ÛŒÚ¤
              $detachContent = "select vdisk file=`"${{ env.VHD_PATH }}`"`n"
              $detachContent += "detach vdisk`n"
              
              $detachContent | Out-File -FilePath "$env:TEMP\detach_restore.txt" -Encoding ASCII
              diskpart /s "$env:TEMP\detach_restore.txt"
          }
          
          Write-Host "âœ… Ø³ÛŒØ³ØªÛ•Ù…ÛŒ Ù‡Û•Ù…ÛŒØ´Û•ÛŒÛŒ Ø¦Ø§Ù…Ø§Ø¯Û•Ú©Ø±Ø§"

      - name: Ú•ÛÚ©Ø®Ø³ØªÙ†ÛŒ RDP
        run: |
          # Ù¡. RDP ÙØ¹Ø§Ù„ Ø¨Ú©Û•
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
            
          # Ù¢. Ù¾Ø§Ø±Ø§Ø³ØªÙ† Ù†Û•ÙˆÛØª
          Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp' -Name "UserAuthentication" -Value 0
            
          # Ù£. WallÛŒ Ø¦Ø§Ú¯Ø±
          netsh advfirewall firewall add rule name="RDP" dir=in action=allow protocol=TCP localport=3389
            
          # Ù¤. Ø¯Ø±ÙˆØ³ØªÚ©Ø±Ø¯Ù†ÛŒ Ø¨Û•Ú©Ø§Ø±Ù‡ÛÙ†Û•Ø±
          $securePass = ConvertTo-SecureString "${{ env.RDP_PASS }}" -AsPlainText -Force
          New-LocalUser -Name "${{ env.RDP_USER }}" -Password $securePass -AccountNeverExpires
          Add-LocalGroupMember -Group "Administrators" -Member "${{ env.RDP_USER }}"
          
          # Ù¥. Ú•ÛÚ©Ø®Ø³ØªÙ†ÛŒ Ø¨Û† Ù‡Û•Ù…ÙˆÙˆ Ø¨Û•Ú©Ø§Ø±Ù‡ÛÙ†Û•Ø±Û•Ú©Ø§Ù†
          Set-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\Control\Terminal Server' -Name "fSingleSessionPerUser" -Value 0
            
          # Ù¦. Restart Ú©Ø±Ø¯Ù†
          Restart-Service TermService -Force
          
          Write-Host "âœ… RDP Ø¦Ø§Ù…Ø§Ø¯Û•Û•"

      - name: Ø¯Ø§Ù†Ø§Ù†ÛŒ Tailscale Ø¨Û† Ø¦Ø§ÛŒÙ¾ÛŒ Ù‡Û•Ù…ÛŒØ´Û•ÛŒÛŒ
        run: |
          # Ø¯Ø§Ù†Ø§Ù†ÛŒ Tailscale
          $tsUrl = "https://pkgs.tailscale.com/stable/tailscale-setup-latest-amd64.msi"
          $installer = "$env:TEMP\tailscale.msi"
          
          Invoke-WebRequest -Uri $tsUrl -OutFile $installer
          Start-Process msiexec.exe -ArgumentList "/i", "$installer", "/quiet", "/norestart" -Wait
          
          # Ø¯Û•Ø³ØªÙ¾ÛÚ©Ø±Ø¯Ù†ÛŒ Tailscale
          Start-Sleep -Seconds 10
          & "$env:ProgramFiles\Tailscale\tailscale.exe" up --authkey=${{ secrets.TAILSCALE_AUTH_KEY }} --hostname=persistent-rdp-${{ github.run_id }} --accept-routes=true --advertise-exit-node
            
          # Ú†Ø§ÙˆÛ•Ú•ÙˆØ§Ù†ÛŒ Ø¨Û† IP
          Start-Sleep -Seconds 30
          $tsIP = & "$env:ProgramFiles\Tailscale\tailscale.exe" ip -4
          echo "TAILSCALE_IP=$tsIP" >> $env:GITHUB_ENV
          echo "PERSISTENT_IP=$tsIP" >> $env:GITHUB_ENV
          
          Write-Host "ğŸŒ Ø¦Ø§ÛŒÙ¾ÛŒ Ù‡Û•Ù…ÛŒØ´Û•ÛŒÛŒ: $tsIP"

      - name: Ù†Ù…Ø§ÛŒØ´ÛŒ Ø²Ø§Ù†ÛŒØ§Ø±ÛŒ
        run: |
          Write-Host "========================================"
          Write-Host "ğŸš€ Windows RPD Ø¨Ø§ Ø³ÛŒØ³ØªÛ•Ù…ÛŒ Ù‡Û•Ù…ÛŒØ´Û•ÛŒÛŒ"
          Write-Host "========================================"
          Write-Host "ğŸŒ Ø¦Ø§ÛŒÙ¾ÛŒ Ù‡Û•Ù…ÛŒØ´Û•ÛŒÛŒ: $env:TAILSCALE_IP"
          Write-Host "ğŸ‘¤ Ø¨Û•Ú©Ø§Ø±Ù‡ÛÙ†Û•Ø±: ${{ env.RDP_USER }}"
          Write-Host "ğŸ” ÙˆØ´Û•ÛŒ Ù†Ù‡ÛÙ†ÛŒ: ${{ env.RDP_PASS }}"
          Write-Host ""
          Write-Host "âœ¨ ØªØ§ÛŒØ¨Û•ØªÙ…Û•Ù†Ø¯ÛŒÛ•Ú©Ø§Ù†:"
          Write-Host "â€¢ Ù‡Û•Ù…ÙˆÙˆ Ø¯Ø§ØªØ§ + Ø³ÛŒØ³ØªÛ•Ù… Ù‡Û•ÚµØ¯Û•Ú¯ÛŒØ±ÛØª"
          Write-Host "â€¢ ProgramÛ•Ú©Ø§Ù† Ù†Ø§Ø³Ú•ÛÙ†Û•ÙˆÛ•"
          Write-Host "â€¢ Ú•ÛÚ©Ø®Ø³ØªÙ†Û•Ú©Ø§Ù† Ù¾Ø§Ø±ÛØ²Ø±Ø§ÙˆÙ†"
          Write-Host "â€¢ ÙØ§ÛŒÙ„Û•Ú©Ø§Ù† Ø¯Û•Ù…ÛÙ†Ù†Û•ÙˆÛ•"
          Write-Host ""
          Write-Host "ğŸ’¡ Ú•ÛÙ†Ù…Ø§ÛŒÛŒ:"
          Write-Host "1. Ù‡Û•Ø±Ú†ÛŒ Ø¯Ø§ÛŒØ¨Ù†ÛØŒ Ø¯Û•Ù…ÛÙ†ÛØªÛ•ÙˆÛ•"
          Write-Host "2. ProgramÛ•Ú©Ø§Ù† Ø¯Ø§Ø¯Û•Ù†ÛØŒ Ø¯ÙˆÙˆØ¨Ø§Ø±Û• Ù†Ø§Ø¨Û Ø¯Ø§Ø¯Û•Ù†ÛÛŒØªÛ•ÙˆÛ•"
          Write-Host "3. Ú©Ø§ØªÛÚ© Ø¯ÙˆÙˆØ¨Ø§Ø±Û• Ø¯Û•Ø³ØªÙ¾ÛØ¯Û•Ú©Û•ÛŒØªØŒ Ù‡Û•Ù…ÙˆÙˆ Ø´ØªÛÚ© ÙˆÛ•Ú© Ù¾ÛØ´ØªØ±Û•"
          Write-Host "========================================"
          
          # Ø¯Ø§Ù†Ø§Ù†ÛŒ Ú©Ø§ØªÛŒ Ú©Û†ØªØ§ÛŒÛŒ (Ù¥ Ú©Ø§ØªÚ˜Ù…ÛØ±)
          Write-Host "â° Ø³ÛŒØ³ØªÙ… Ø®Û†Ú©Ø§Ø±Ø§Ù†Û• Ø¯Û•Ú©ÙˆÚ˜ÛØªÛ•ÙˆÛ• Ø¯ÙˆØ§ÛŒ Ù¥ Ú©Ø§ØªÚ˜Ù…ÛØ±..."
          
          $timerContent = "$endTime = (Get-Date).AddHours(5)`n"
          $timerContent += "$checkInterval = 300  # Ù¥ Ø®ÙˆÙ„Û•Ú©`n`n"
          $timerContent += "while ((Get-Date) -lt `$endTime) {`n"
          $timerContent += "    `$remaining = `$endTime - (Get-Date)`n"
          $timerContent += "    `$hours = [math]::Floor(`$remaining.TotalHours)`n"
          $timerContent += "    `$minutes = [math]::Floor(`$remaining.TotalMinutes) % 60`n`n"
          $timerContent += "    Write-Host `"[`$(Get-Date -Format 'HH:mm:ss')] Ù…Ø§ÙˆÛ•ÛŒ Ù…Ø§Ø¨ÙˆÙˆÛ•: `$hours Ú©Ø§ØªÚ˜Ù…ÛØ± `$minutes Ø®ÙˆÙ„Û•Ú©`"`n`n"
          $timerContent += "    Start-Sleep -Seconds `$checkInterval`n"
          $timerContent += "}`n`n"
          $timerContent += "Write-Host `"ğŸ•’ Ú©Ø§ØªÛŒ ØªÛ•ÙˆØ§Ùˆ Ø¨ÙˆÙˆÙ†! `$(Get-Date)`"`n"
          $timerContent += "Write-Host `"Ø³ÛŒØ³ØªÛ•Ù… Ø®Û†Ú©Ø§Ø±Ø§Ù†Û• Ø¯Û•Ú©ÙˆÚ˜ÛØªÛ•ÙˆÛ•`"`n"
          
          $timerContent | Out-File -FilePath "$env:TEMP\shutdown_timer.ps1" -Encoding UTF8
          Start-Process powershell -ArgumentList "-File $env:TEMP\shutdown_timer.ps1" -NoNewWindow

      - name: BackupÛŒ Ú©Û†ØªØ§ÛŒÛŒ Ù¾ÛØ´ Ú©ÙˆÚ˜Ø§Ù†Û•ÙˆÛ•
        run: |
          Write-Host "ğŸ’¾ Ù‡Û•ÚµÚ¯Ø±ØªÙ†ÛŒ Ú©Û†ØªØ§ÛŒÛŒ Ù¾ÛØ´ Ú©ÙˆÚ˜Ø§Ù†Û•ÙˆÛ•..."
          
          # Ù¡. Ø¯Ø±ÙˆØ³ØªÚ©Ø±Ø¯Ù†ÛŒ Backup ÙÛ†ÚµØ¯Û•Ø±
          $backupDir = "$env:TEMP\Final_Backup_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
          New-Item -ItemType Directory -Path $backupDir -Force
          
          # Ù¢. Ù‡Û•ÚµÚ¯Ø±ØªÙ†ÛŒ Ø¨Û•Ú©Ø§Ø±Ù‡ÛÙ†Û•Ø±Ø§Ù†
          $usersBackup = "$backupDir\Users_Backup.zip"
          if (Test-Path "C:\Users") {
              $userFolders = Get-ChildItem "C:\Users" -Directory | Where-Object {$_.Name -notin @("Public", "Default", "Default.migrated")}
              
              foreach ($user in $userFolders) {
                  $userBackup = "$backupDir\$($user.Name)_Backup.zip"
                  try {
                      Compress-Archive -Path $user.FullName -DestinationPath $userBackup -CompressionLevel Optimal -ErrorAction SilentlyContinue
                      Write-Host "âœ… $($user.Name) Ù‡Û•ÚµÚ¯ÛŒØ±Ø§"
                  } catch {
                      Write-Host "âš ï¸ Ù†Û•ØªÙˆØ§Ù†Ø±Ø§ $($user.Name) Ù‡Û•ÚµØ¨Ú¯ÛŒØ±ÛØª"
                  }
              }
          }
          
          # Ù£. Ù‡Û•ÚµÚ¯Ø±ØªÙ†ÛŒ Programs Ù„ÛŒØ³Øª
          Write-Host "ğŸ“¦ Ù‡Û•ÚµÚ¯Ø±ØªÙ†ÛŒ Programs Ù„ÛŒØ³Øª..."
          try {
              Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
                  Select-Object DisplayName, DisplayVersion, Publisher, InstallDate | 
                  Where-Object {$_.DisplayName} |
                  Export-Csv "$backupDir\Installed_Programs.csv" -NoTypeInformation -Encoding UTF8
          } catch {
              # Alternative method
              Get-WmiObject -Class Win32_Product | Select-Object Name, Version, InstallDate | 
                  Export-Csv "$backupDir\Installed_Programs_WMI.csv" -NoTypeInformation -Encoding UTF8
          }
          
          # Ù¤. Ù‡Û•ÚµÚ¯Ø±ØªÙ†ÛŒ Registry
          Write-Host "ğŸ”§ Ù‡Û•ÚµÚ¯Ø±ØªÙ†ÛŒ Registry..."
          try {
              reg export "HKCU" "$backupDir\HKCU_Backup.reg" /y
              reg export "HKLM\Software" "$backupDir\HKLM_Software_Backup.reg" /y
          } catch {
              Write-Host "âš ï¸ Registry Ù‡Û•ÚµÚ¯Ø±ØªÙ† Ø´Ú©Ø³ØªÛŒ Ù‡ÛÙ†Ø§"
          }
          
          # Ù¥. Ù‡Û•ÚµÚ¯Ø±ØªÙ†ÛŒ Desktop, Documents, Downloads
          $importantFolders = @("Desktop", "Documents", "Downloads", "Pictures", "Videos")
          foreach ($folder in $importantFolders) {
              $userFolder = "C:\Users\${{ env.RDP_USER }}\$folder"
              if (Test-Path $userFolder) {
                  $folderBackup = "$backupDir\${folder}_Backup.zip"
                  try {
                      Compress-Archive -Path $userFolder -DestinationPath $folderBackup -CompressionLevel Optimal -ErrorAction SilentlyContinue
                  } catch { }
              }
          }
          
          # Ù¦. Ú©Û†ÛŒ Ú¯Û•ÙˆØ±Û•ÛŒÛŒ
          $totalSize = (Get-ChildItem $backupDir -Recurse | Measure-Object -Property Length -Sum).Sum / 1MB
          Write-Host "âœ… Ù‡Û•Ù…ÙˆÙˆ Ø¯Ø§ØªØ§Ú©Ø§Ù† Ù‡Û•ÚµÚ¯ÛŒØ±Ø§Ù†"
          Write-Host "ğŸ“Š Ú©Û†ÛŒ Ú¯Û•ÙˆØ±Û•ÛŒÛŒ: $([math]::Round($totalSize, 2)) MB"
          Write-Host "ğŸ“ ÙÛ†ÚµØ¯Û•Ø±ÛŒ Backup: $backupDir"
